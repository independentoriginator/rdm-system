create or replace procedure p_build_target_table(
	i_type_rec record
)
language plpgsql
as $procedure$
declare 
	l_attr_rec record;
	l_index_rec record;
	l_is_pk_index_exists boolean := i_type_rec.is_pk_index_exists;
	l_table_rec record;
begin
	if i_type_rec.is_table_exists = false then 
		if i_type_rec.is_temporal = false then
			execute format('
				create table %I.%I(
					id %s not null generated by default as identity,
					record_date timestamp without time zone default current_timestamp not null
				)'
				, i_type_rec.schema_name
				, i_type_rec.internal_name
				, '${type.id}'
			);
		else
			execute format('
				create table %I.%I(
					id %s not null generated by default as identity,
					version %s not null generated by default as identity,
					valid_from timestamp without time zone default current_timestamp not null,
					valid_to timestamp without time zone not null,
					record_date timestamp without time zone default current_timestamp not null	
				)'
				, i_type_rec.schema_name
				, i_type_rec.internal_name
				, '${type.id}'
				, '${type.id}'
			);
		end if;
	else
		if i_type_rec.is_temporal = true and i_type_rec.is_target_table_non_temporal = true then
			raise exception 
				'%. %: non-temporal to temporal entity conversion is not supported;'
				'in this case, a new entity with a different name is expected to be created'
				, i_type_rec.schema_name
				, i_type_rec.internal_name
			;
		end if;
	end if;

	-- ETL user role read permission
	if length('${etlUserRole}') > 0 
	then
		execute	
			format(
				'grant select on %I.%I to ${etlUserRole}'
				, i_type_rec.schema_name
				, i_type_rec.internal_name 
			
			);
	end if;
	
	call ${mainSchemaName}.p_build_target_staging_table(
		i_type_rec => i_type_rec
	);

	if i_type_rec.is_pk_index_exists = false and i_type_rec.is_temporal = false then
		execute format('
			create unique index %I on %I.%I (
				id
			)'
			, i_type_rec.pk_index_name 
			, i_type_rec.schema_name
			, i_type_rec.internal_name 
		);
	elsif i_type_rec.is_temporal = true then
		if i_type_rec.is_pk_index_exists = true and i_type_rec.is_target_table_non_temporal = true then
			execute format('
				alter table %I.%I drop constraint %I cascade
				'
				, i_type_rec.schema_name
				, i_type_rec.internal_name 
				, i_type_rec.pk_index_name
				, i_type_rec.schema_name
				, i_type_rec.pk_index_name
			);
			l_is_pk_index_exists := false;
		end if;
		
		if l_is_pk_index_exists = false then
			execute format('
				create unique index %I on %I.%I (
					id, version
				)'
				, i_type_rec.pk_index_name 
				, i_type_rec.schema_name
				, i_type_rec.internal_name 
			);
			execute format('
				create unique index ui_%I$id_valid_to on %I.%I (
					id, valid_to
				)'
				, i_type_rec.internal_name 
				, i_type_rec.schema_name
				, i_type_rec.internal_name 
			);
		end if;
	end if;

	if i_type_rec.is_pk_constraint_exists = false 
		or (i_type_rec.is_temporal = true and i_type_rec.is_target_table_non_temporal = true) 
	then 
		execute format('
			alter table %I.%I
				add constraint %I primary key using index %I
			'
			, i_type_rec.schema_name
			, i_type_rec.internal_name 
			, i_type_rec.pk_index_name 
			, i_type_rec.pk_index_name				
		);
	end if;
	
	if nullif(i_type_rec.table_description, i_type_rec.target_table_description) is not null then
		execute format($$
			comment on table %I.%I is $comment$%s$comment$
			$$
			, i_type_rec.schema_name
			, i_type_rec.internal_name
			, i_type_rec.table_description
		);
	end if;	
	
	for l_attr_rec in (
		select
			a.*
		from 
			${mainSchemaName}.v_meta_attribute a
		where 
			a.master_id = i_type_rec.id
		order by 
			ordinal_position asc nulls last, 
			id asc 
	) 
	loop
		call ${mainSchemaName}.p_build_target_column(
			i_type_rec => i_type_rec,
			i_attr_rec => l_attr_rec
		);
		call ${mainSchemaName}.p_build_target_staging_table_column(
			i_type_rec => i_type_rec,
			i_attr_rec => l_attr_rec
		);
	end loop;	
	
	for l_index_rec in (
		select
			i.*
		from 
			${mainSchemaName}.v_meta_index i
		where 
			i.master_id = i_type_rec.id
	) 
	loop
		call ${mainSchemaName}.p_build_target_index(
			i_index_rec => l_index_rec
		);
	end loop;
	
	call ${mainSchemaName}.p_build_target_lc_table(
		i_type_rec => i_type_rec
	);

	call ${mainSchemaName}.p_build_target_api(
		i_type_rec => i_type_rec
	);

	update ${mainSchemaName}.meta_type 
	set is_built = true
	where id = i_type_rec.id
	;
end
$procedure$;	

comment on procedure p_build_target_table(
	record
) is 'Генерация целевой таблицы';
